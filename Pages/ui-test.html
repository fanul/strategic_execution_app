<!-- ui-test.html - Enhanced with Functional CRUD Testing -->
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pb-2 mb-3 border-bottom">
    <h1 class="h2"><i class="bi bi-clipboard-check"></i> Automated Testing</h1>
    <div class="btn-toolbar mb-2 mb-md-0">
        <div class="btn-group me-2" role="group">
            <button type="button" class="btn btn-sm btn-outline-primary active" id="btnUIMode" onclick="setTestMode('ui')">
                <i class="bi bi-ui-checks"></i> UI Tests
            </button>
            <button type="button" class="btn btn-sm btn-outline-success" id="btnFunctionalMode" onclick="setTestMode('functional')">
                <i class="bi bi-gear-fill"></i> Functional Tests
            </button>
        </div>
        <button type="button" class="btn btn-sm btn-primary me-2" onclick="runTests()" id="btnRunTests">
            <i class="bi bi-play-circle"></i> Run Tests
        </button>
        <button type="button" class="btn btn-sm btn-warning me-2" onclick="cleanupTestData()" id="btnCleanup" style="display:none;">
            <i class="bi bi-trash"></i> Cleanup Test Data
        </button>
        <button type="button" class="btn btn-sm btn-success" onclick="exportResults()">
            <i class="bi bi-download"></i> Export Results
        </button>
    </div>
</div>

<!-- Alert for Functional Tests -->
<div class="alert alert-warning alert-dismissible fade" id="functionalAlert" role="alert" style="display:none;">
    <strong><i class="bi bi-exclamation-triangle"></i> Warning:</strong> Functional tests will create real data in your database. Make sure to run cleanup after testing.
    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
</div>

<!-- Test Progress -->
<div class="row mb-4">
    <div class="col-md-12">
        <div class="card shadow-sm">
            <div class="card-body">
                <div id="testProgress" class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="mb-0">Test Progress</h6>
                        <span id="progressText" class="text-muted">Ready to start</span>
                    </div>
                    <div class="progress" style="height: 25px;">
                        <div id="progressBar" class="progress-bar progress-bar-striped" role="progressbar" style="width: 0%">0%</div>
                    </div>
                </div>
                
                <div class="row text-center">
                    <div class="col-3">
                        <h4 id="totalTests" class="mb-0">0</h4>
                        <small class="text-muted">Total Tests</small>
                    </div>
                    <div class="col-3">
                        <h4 id="passedTests" class="mb-0 text-success">0</h4>
                        <small class="text-muted">Passed</small>
                    </div>
                    <div class="col-3">
                        <h4 id="failedTests" class="mb-0 text-danger">0</h4>
                        <small class="text-muted">Failed</small>
                    </div>
                    <div class="col-3">
                        <h4 id="warningTests" class="mb-0 text-warning">0</h4>
                        <small class="text-muted">Warnings</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Test Results -->
<div class="row">
    <div class="col-md-12">
        <div class="card shadow-sm">
            <div class="card-header bg-light">
                <h6 class="m-0">Test Results</h6>
            </div>
            <div class="card-body">
                <div id="testResults">
                    <p class="text-muted text-center py-4">Select a test mode and click "Run Tests" to begin</p>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
.test-module {
    border-left: 3px solid #0d6efd;
    margin-bottom: 1rem;
}
.test-item {
    padding: 0.5rem 1rem;
    border-bottom: 1px solid #eee;
}
.test-item:last-child {
    border-bottom: none;
}
.test-pass {
    background-color: #d1e7dd;
    border-left-color: #198754;
}
.test-fail {
    background-color: #f8d7da;
    border-left-color: #dc3545;
}
.test-warn {
    background-color: #fff3cd;
    border-left-color: #ffc107;
}
.test-details {
    font-size: 0.875rem;
    color: #6c757d;
    margin-top: 0.25rem;
}
.btn-group .btn.active {
    background-color: #0d6efd;
    color: white;
    border-color: #0d6efd;
}
</style>

<script>
let testMode = 'ui'; // 'ui' or 'functional'
let testResults = [];
let createdTestData = []; // Track created test data for cleanup
let currentTest = 0;
let totalTestCount = 0;
let passCount = 0;
let failCount = 0;
let warnCount = 0;
// Test specifications
const testSpecs = {
    organization: {
        name: 'Organization Management',
        pages: ['organization.html'],
        tests: [
            {
                name: 'Directorates Section',
                type: 'section',
                checks: [
                    { selector: 'table#directoratesTable', desc: 'Directorates DataTable exists' },
                    { selector: 'button[data-bs-target="#newOrgModal"]', desc: 'Add New button exists' },
                    { selector: 'th:contains("Code")', desc: 'Table has Code column' },
                    { selector: 'th:contains("Name")', desc: 'Table has Name column' },
                    { selector: 'th:contains("Director")', desc: 'Table has Director column' },
                    { selector: 'th:contains("Actions")', desc: 'Table has Actions column' }
                ]
            },
            {
                name: 'Work Units Tab',
                type: 'section',
                checks: [
                    { selector: '#workunits-tab', desc: 'Work Units tab exists' },
                    { selector: '#workunits', desc: 'Work Units tab content exists' }
                ]
            },
            {
                name: 'Organization Modal',
                type: 'modal',
                checks: [
                    { selector: '#newOrgModal', desc: 'Organization modal exists' },
                    { selector: '#orgTypeSelector', desc: 'Entity type selector exists' }
                ]
            }
        ]
    },
    
    kpi: {
        name: 'KPI Management',
        pages: ['kpi.html'],
        tests: [
            {
                name: 'Organizational KPIs Tab',
                type: 'section',
                checks: [
                    { selector: 'table#orgKPITable', desc: 'Organizational KPI DataTable exists' },
                    { selector: 'button[onclick*="createNewKPI"]', desc: 'Create KPI button exists' },
                    { selector: '#orgKPITable th:contains("Code")', desc: 'Table has Code column' },
                    { selector: '#orgKPITable th:contains("Name")', desc: 'Table has Name column' },
                    { selector: '#orgKPITable th:contains("Type")', desc: 'Table has Type column' },
                    { selector: '#orgKPITable th:contains("Target")', desc: 'Table has Target column' },
                    { selector: '#orgKPITable th:contains("Progress")', desc: 'Table has Progress column' }
                ]
            },
            {
                name: 'Individual KPIs Tab',
                type: 'section',
                checks: [
                    { selector: 'table#indKPITable', desc: 'Individual KPI DataTable exists' },
                    { selector: '#ind-kpi-tab', desc: 'Individual KPI tab exists' }
                ]
            }
        ]
    },
    
    okr: {
        name: 'OKR Management',
        pages: ['okr.html'],
        tests: [
            {
                name: 'Weekly OKRs Section',
                type: 'section',
                checks: [
                    { selector: '#weekSelector', desc: 'Week selector exists' },
                    { selector: 'button[onclick*="createNewOKR"]', desc: 'Create OKR button exists' },
                    { selector: '#myOKRsContent', desc: 'My OKRs content area exists' }
                ]
            }
        ]
    },
    
    programs: {
        name: 'Programs & Activities',
        pages: ['programs.html'],
        tests: [
            {
                name: 'Programs Table',
                type: 'section',
                checks: [
                    { selector: 'table#programsTable', desc: 'Programs DataTable exists' },
                    { selector: 'button[onclick*="createProgram"]', desc: 'Create Program button exists' }
                ]
            }
        ]
    },
    
    impactCenters: {
        name: 'Impact Centers',
        pages: ['impact-centers.html'],
        tests: [
            {
                name: 'Impact Centers Table',
                type: 'section',
                checks: [
                    { selector: 'table#impactCentersTable', desc: 'Impact Centers DataTable exists' },
                    { selector: 'button[onclick*="createImpactCenter"]', desc: 'Create Impact Center button exists' }
                ]
            }
        ]
    },
    
    strategicPlan: {
        name: 'Strategic Planning',
        pages: ['strategic-plan.html'],
        tests: [
            {
                name: 'Navigation Tabs',
                type: 'section',
                checks: [
                    { selector: '#periods-tab', desc: 'Periods tab exists' },
                    { selector: '#vision-tab', desc: 'Vision & Mission tab exists' }
                ]
            }
        ]
    }
};

// Set test mode
function setTestMode(mode) {
    testMode = mode;
    
    // Update button states
    document.getElementById('btnUIMode').classList.toggle('active', mode === 'ui');
    document.getElementById('btnFunctionalMode').classList.toggle('active', mode === 'functional');
    
    // Show/hide alert and cleanup
    const alert = document.getElementById('functionalAlert');
    const cleanup = document.getElementById('btnCleanup');
    
    if (mode === 'functional') {
        alert.style.display = 'block';
        alert.classList.add('show');
        cleanup.style.display = 'inline-block';
    } else {
        alert.style.display = 'none';
        alert.classList.remove('show');
        cleanup.style.display = 'none';
    }
    
    // Reset results
    document.getElementById('testResults').innerHTML = '<p class="text-muted text-center py-4">Click "Run Tests" to begin</p>';
}

// Unified test runner
async function runTests() {
    if (testMode === 'ui') {
        await runUITests();
    } else {
        if (confirm('Functional tests will create real data in your database. Continue?')) {
            await runFunctionalTests();
        }
    }
}

// UI Tests (original functionality)
async function runUITests() {
    testResults = [];
    currentTest = 0;
    passCount = 0;
    failCount = 0;
    warnCount = 0;
    
    totalTestCount = 0;
    for (let module in testSpecs) {
        testSpecs[module].tests.forEach(test => {
            totalTestCount += test.checks.length;
        });
    }
    
    document.getElementById('totalTests').textContent = totalTestCount;
    document.getElementById('testResults').innerHTML = '<p class="text-muted">Running UI tests...</p>';
    
    for (let moduleKey in testSpecs) {
        await runModuleUITests(moduleKey, testSpecs[moduleKey]);
    }
    
    displayResults();
}

async function runModuleUITests(moduleKey, module) {
    const moduleResults = {
        name: module.name,
        tests: []
    };
    
    updateProgress(`Testing ${module.name}...`);
    
    for (let test of module.tests) {
        const testResult = {
            name: test.name,
            type: test.type,
            checks: []
        };
        
        for (let check of test.checks) {
            currentTest++;
            const result = await runUICheck(check);
            testResult.checks.push(result);
            
            if (result.status === 'pass') passCount++;
            else if (result.status === 'fail') failCount++;
            else if (result.status === 'warn') warnCount++;
            
            updateCounters();
            await sleep(50);
        }
        
        moduleResults.tests.push(testResult);
    }
    
    testResults.push(moduleResults);
}

async function runUICheck(check) {
    try {
        let element = null;
        
        if (check.selector.includes(':contains(')) {
            const match = check.selector.match(/(.+):contains\("(.+)"\)/);
            if (match) {
                const baseSelector = match[1];
                const text = match[2];
                const elements = document.querySelectorAll(baseSelector);
                for (let el of elements) {
                    if (el.textContent.includes(text)) {
                        element = el;
                        break;
                    }
                }
            }
        } else {
            element = document.querySelector(check.selector);
        }
        
        if (element) {
            return {
                desc: check.desc,
                status: 'pass',
                message: 'Element found',
                selector: check.selector
            };
        } else {
            return {
                desc: check.desc,
                status: 'fail',
                message: 'Element not found',
                selector: check.selector
            };
        }
    } catch (error) {
        return {
            desc: check.desc,
            status: 'warn',
            message: `Test error: ${error.message}`,
            selector: check.selector
        };
    }
}

// Functional Tests (NEW)
async function runFunctionalTests() {
    testResults = [];
    createdTestData = [];
    currentTest = 0;
    passCount = 0;
    failCount = 0;
    warnCount = 0;
    
    totalTestCount = 6; // One CREATE, EDIT, DELETE test per 2 main modules
    document.getElementById('totalTests').textContent = totalTestCount;
    document.getElementById('testResults').innerHTML = '<p class="text-muted">Running functional CRUD tests...</p>';
    
    // Test Impact Centers (simpler module)
    await testImpactCenterCRUD();
    
    // Test Programs
    await testProgramCRUD();
    
    displayResults();
    
    if (createdTestData.length > 0) {
        showToast(`Created ${createdTestData.length} test records. Use Cleanup button to remove them.`, 'Tests Complete');
    }
}

// Impact Center CRUD Tests
async function testImpactCenterCRUD() {
    const moduleResults = {
        name: 'Impact Centers - Functional CRUD',
        tests: []
    };
    
    let testIC = null;
    
    // CREATE TEST
    updateProgress('Testing Impact Center CREATE...');
    currentTest++;
    const createResult = await testCreateImpactCenter();
    moduleResults.tests.push({
        name: 'Create Impact Center',
        type: 'functional',
        checks: [createResult]
    });
    
    if (createResult.status === 'pass') {
        passCount++;
        testIC = createResult.data;
        createdTestData.push({ type: 'impact_center', id: testIC.impact_center_id });
    } else {
        failCount++;
    }
    updateCounters();
    await sleep(500);
    
    // EDIT TEST (only if create succeeded)
    if (testIC) {
        updateProgress('Testing Impact Center EDIT...');
        currentTest++;
        const editResult = await testEditImpactCenter(testIC.impact_center_id);
        moduleResults.tests.push({
            name: 'Edit Impact Center',
            type: 'functional',
            checks: [editResult]
        });
        
        if (editResult.status === 'pass') passCount++;
        else failCount++;
        updateCounters();
        await sleep(500);
    }
    
    // DELETE  TEST (only if create succeeded)
    if (testIC) {
        updateProgress('Testing Impact Center DELETE...');
        currentTest++;
        const deleteResult = await testDeleteImpactCenter(testIC.impact_center_id);
        moduleResults.tests.push({
            name: 'Delete Impact Center',
            type: 'functional',
            checks: [deleteResult]
        });
        
        if (deleteResult.status === 'pass') {
            passCount++;
            // Remove from cleanup list since it's deleted
            createdTestData = createdTestData.filter(d => d.id !== testIC.impact_center_id);
        } else {
            failCount++;
        }
        updateCounters();
        await sleep(500);
    }
    
    testResults.push(moduleResults);
}

async function testCreateImpactCenter() {
    try {
        const timestamp = Date.now();
        const testData = {
            ic_name: `TEST Auto Impact Center ${timestamp}`,
            ic_code: `TEST-IC-${timestamp}`,
            year: 2026,
            goal_id: 'test-goal-id', // Required field
            deliverable: 'Test Deliverable', // Required field
            description: 'Automated test impact center',
            baseline_value: 0,
            target_value: 100,
            created_by: 'test-user',
            is_active: true
        };
       
        const response = await callAPI('impact-centers/saveImpactCenter', testData);
        
        if (response && response.success && response.data) {
            return {
                desc: 'Create Impact Center via API',
                status: 'pass',
                message: `Created IC: ${response.data.ic_id || response.data.impact_center_id}`,
                data: response.data
            };
        } else {
            return {
                desc: 'Create Impact Center via API',
                status: 'fail',
                message: `API Error: ${response?.message || response?.error || 'No data returned'} | Response: ${JSON.stringify(response)}`
            };
        }
    } catch (error) {
        return {
            desc: 'Create Impact Center via API',
            status: 'fail',
            message: `Exception: ${error.message} | Stack: ${error.stack}`
        };
    }
}

async function testEditImpactCenter(id) {
    try {
        const updateData = {
            ic_id: id,
            ic_name: `TEST EDITED Impact Center ${Date.now()}`,
            updated_by: 'test-user'
        };
        
        const response = await callAPI('impact-centers/saveImpactCenter', updateData);
        
        if (response && response.success) {
            return {
                desc: 'Edit Impact Center via API',
                status: 'pass',
                message: `Updated IC: ${id}`
            };
        } else {
            return {
                desc: 'Edit Impact Center via API',
                status: 'fail',
                message: `Update failed: ${response?.message || response?.error || 'Unknown error'}`
            };
        }
    } catch (error) {
        return {
            desc: 'Edit Impact Center via API',
            status: 'fail',
            message: `Exception: ${error.message}`
        };
    }
}

async function testDeleteImpactCenter(id) {
    try {
        const response = await callAPI('impact-centers/deleteImpactCenter', { ic_id: id });
        
        if (response && response.success) {
            return {
                desc: 'Delete Impact Center via API',
                status: 'pass',
                message: `Deleted IC: ${id}`
            };
        } else {
            return {
                desc: 'Delete Impact Center via API',
                status: 'fail',
                message: `Delete failed: ${response?.message || response?.error || 'Unknown error'}`
            };
        }
    } catch (error) {
        return {
            desc: 'Delete Impact Center via API',
            status: 'fail',
            message: `Exception: ${error.message}`
        };
    }
}

// Program CRUD Tests
async function testProgramCRUD() {
    const moduleResults = {
        name: 'Programs - Functional CRUD',
        tests: []
    };
    
    let testProgram = null;
    
    // CREATE TEST
    updateProgress('Testing Program CREATE...');
    currentTest++;
    const createResult = await testCreateProgram();
    moduleResults.tests.push({
        name: 'Create Program',
        type: 'functional',
        checks: [createResult]
    });
    
    if (createResult.status === 'pass') {
        passCount++;
        testProgram = createResult.data;
        createdTestData.push({ type: 'program', id: testProgram.program_id });
    } else {
        failCount++;
    }
    updateCounters();
    await sleep(500);
    
    // EDIT TEST
    if (testProgram) {
        updateProgress('Testing Program EDIT...');
        currentTest++;
        const editResult = await testEditProgram(testProgram.program_id);
        moduleResults.tests.push({
            name: 'Edit Program',
            type: 'functional',
            checks: [editResult]
        });
        
        if (editResult.status === 'pass') passCount++;
        else failCount++;
        updateCounters();
        await sleep(500);
    }
    
    // DELETE TEST
    if (testProgram) {
        updateProgress('Testing Program DELETE...');
        currentTest++;
        const deleteResult = await testDeleteProgram(testProgram.program_id);
        moduleResults.tests.push({
            name: 'Delete Program',
            type: 'functional',
            checks: [deleteResult]
        });
        
        if (deleteResult.status === 'pass') {
            passCount++;
            createdTestData = createdTestData.filter(d => d.id !== testProgram.program_id);
        } else {
            failCount++;
        }
        updateCounters();
        await sleep(500);
    }
    
    testResults.push(moduleResults);
}

async function testCreateProgram() {
    try {
        const timestamp = Date.now();
        const testData = {
            program_name: `TEST Auto Program ${timestamp}`,
            program_code: `TEST-PRG-${timestamp}`,
            program_description: 'Automated test program',
            budget_allocated: 1000000,
            created_by: 'test-user'
        };
        
        const response = await callAPI('programs/saveProgram', testData);
        
        if (response && response.success && response.data) {
            return {
                desc: 'Create Program via API',
                status: 'pass',
                message: `Created Program: ${response.data.program_id}`,
                data: response.data
            };
        } else {
            return {
                desc: 'Create Program via API',
                status: 'fail',
                message: `API Error: ${response?.message || response?.error || 'No data returned'} | Response: ${JSON.stringify(response)}`
            };
        }
    } catch (error) {
        return {
            desc: 'Create Program via API',
            status: 'fail',
            message: `Exception: ${error.message} | Stack: ${error.stack}`
        };
    }
}

async function testEditProgram(id) {
    try {
        const updateData = {
            program_id: id,
            program_name: `TEST EDITED Program ${Date.now()}`,
            budget_allocated: 2000000,
            updated_by: 'test-user'
        };
        
        const response = await callAPI('programs/saveProgram', updateData);
        
        if (response && response.success) {
            return {
                desc: 'Edit Program via API',
                status: 'pass',
                message: `Updated Program: ${id}`
            };
        } else {
            return {
                desc: 'Edit Program via API',
                status: 'fail',
                message: `Update failed: ${response?.message || response?.error || 'Unknown error'}`
            };
        }
    } catch (error) {
        return {
            desc: 'Edit Program via API',
            status: 'fail',
            message: `Exception: ${error.message}`
        };
    }
}

async function testDeleteProgram(id) {
    try {
        const response = await callAPI('programs/deleteProgram', { program_id: id });
        
        if (response && response.success) {
            return {
                desc: 'Delete Program via API',
                status: 'pass',
                message: `Deleted Program: ${id}`
            };
        } else {
            return {
                desc: 'Delete Program via API',
                status: 'fail',
                message: `Delete failed: ${response?.message || response?.error || 'Unknown error'}`
            };
        }
    } catch (error) {
        return {
            desc: 'Delete Program via API',
            status: 'fail',
            message: `Exception: ${error.message}`
        };
    }
}

// Cleanup test data
async function cleanupTestData() {
    if (createdTestData.length === 0) {
        alert('No test data to cleanup.');
        return;
    }
    
    if (!confirm(`This will delete ${createdTestData.length} test records. Continue?`)) {
        return;
    }
    
    let cleaned = 0;
    for (let item of createdTestData) {
        try {
            if (item.type === 'impact_center') {
                await callAPI('impact-centers/deleteImpactCenter', { impact_center_id: item.id });
                cleaned++;
            } else if (item.type === 'program') {
                await callAPI('programs/deleteProgram', { program_id: item.id });
                cleaned++;
            }
        } catch (error) {
            console.error('Cleanup error:', error);
        }
    }
    
    createdTestData = [];
    showToast(`Cleaned up ${cleaned} test records`, 'Cleanup Complete');
}

// Helper function to call backend API
function callAPI(endpoint, data) {
    return new Promise((resolve, reject) => {
        google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .callAPI(endpoint, data);
    });
}

// Display and export functions (shared)
function updateProgress(text) {
    const percent = Math.round((currentTest / totalTestCount) * 100);
    document.getElementById('progressBar').style.width = percent + '%';
    document.getElementById('progressBar').textContent = percent + '%';
    document.getElementById('progressText').textContent = text;
    
    if (percent === 100) {
        document.getElementById('progressBar').classList.add('bg-success');
    } else {
        document.getElementById('progressBar').classList.remove('bg-success');
    }
}

function updateCounters() {
    document.getElementById('passedTests').textContent = passCount;
    document.getElementById('failedTests').textContent = failCount;
    document.getElementById('warningTests').textContent = warnCount;
}

function displayResults() {
    let html = '';
    
    testResults.forEach(module => {
        html += `
            <div class="test-module card mb-3">
                <div class="card-header bg-primary text-white">
                    <h6 class="mb-0"><i class="bi bi-folder"></i> ${module.name}</h6>
                </div>
                <div class="card-body p-0">
        `;
        
        module.tests.forEach(test => {
            html += `
                <div class="px-3 py-2 bg-light border-bottom">
                    <strong>${test.name}</strong> <span class="badge bg-secondary">${test.type}</span>
                </div>
            `;
            
            test.checks.forEach(check => {
                const statusClass = check.status === 'pass' ? 'test-pass' : 
                                  check.status === 'fail' ? 'test-fail' : 'test-warn';
                const icon = check.status === 'pass' ? 'check-circle' : 
                           check.status === 'fail' ? 'x-circle' : 'exclamation-triangle';
                
                html += `
                    <div class="test-item ${statusClass}">
                        <div class="d-flex justify-content-between align-items-center">
                            <span>
                                <i class="bi bi-${icon} me-2"></i>
                                ${check.desc}
                            </span>
                            <span class="badge bg-${check.status === 'pass' ? 'success' : check.status === 'fail' ? 'danger' : 'warning'}">
                                ${check.status.toUpperCase()}
                            </span>
                        </div>
                        <div class="test-details">
                            ${check.message}
                        </div>
                    </div>
                `;
            });
        });
        
        html += `
                </div>
            </div>
        `;
    });
    
    document.getElementById('testResults').innerHTML = html;
}

function exportResults() {
    if (testResults.length === 0) {
        alert('No test results to export. Please run tests first.');
        return;
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    let output = `${testMode.toUpperCase()} AUTOMATED TEST RESULTS\n`;
    output += `Generated: ${new Date().toLocaleString()}\n`;
    output += `=`.repeat(80) + `\n\n`;
    
    output += `SUMMARY\n`;
    output += `-`.repeat(80) + `\n`;
    output += `Total Tests: ${totalTestCount}\n`;
    output += `Passed: ${passCount} (${((passCount/totalTestCount)*100).toFixed(1)}%)\n`;
    output += `Failed: ${failCount} (${((failCount/totalTestCount)*100).toFixed(1)}%)\n`;
    output += `Warnings: ${warnCount} (${((warnCount/totalTestCount)*100).toFixed(1)}%)\n`;
    output += `\n` + `=`.repeat(80) + `\n\n`;
    
    testResults.forEach(module => {
        output += `MODULE: ${module.name}\n`;
        output += `-`.repeat(80) + `\n`;
        
        module.tests.forEach(test => {
            output += `\n  ${test.name} [${test.type}]\n`;
            
            test.checks.forEach(check => {
                const status = check.status === 'pass' ? '✓' : check.status === 'fail' ? '✗' : '⚠';
                output += `    ${status} ${check.desc}\n`;
                output += `      ${check.message}\n`;
            });
        });
        
        output += `\n`;
    });
    
    output += `=`.repeat(80) + `\n`;
    output += `END OF REPORT\n`;
    
    const blob = new Blob([output], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${testMode}-test-results-${timestamp}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function showToast(message, title = 'System') {
    alert(`${title}: ${message}`);
}
</script>
