<script>
// ============================================================================
// ORGANIZATION PAGE CRUD OPERATIONS
// This file contains CRUD operations specific to the Organization page
// ============================================================================

// Prevent duplicate event handlers
let organizationCrudHandlersSetup = false;

// Save Directorate
async function saveDirectorate() {
    debugLog('CRUD', '=== saveDirectorate START ===');

    // Get form elements
    const idEl = document.getElementById('directorate_id');
    const codeEl = document.getElementById('directorate_code');
    const nameEl = document.getElementById('directorate_name');
    const descEl = document.getElementById('description');

    // Defensive checks
    if (!codeEl || !nameEl || !descEl) {
        debugLog('CRUD', 'FAIL: Required form elements not found');
        showToast('Form not properly initialized. Please try again.', 'error');
        return;
    }

    // Get form values
    const id = idEl ? idEl.value : '';
    const data = {
        directorate_code: codeEl.value,
        directorate_name: nameEl.value,
        description: descEl.value
    };

    const formData = { id: id };
    for (const key in data) {
        formData[key] = data[key];
    }
    debugLog('CRUD', 'Form data:', formData);

    // Validation
    if (!data.directorate_code || !data.directorate_name) {
        debugLog('CRUD', 'FAIL Validation failed: missing required fields');
        showToast('Please fill in all required fields', 'error');
        return;
    }
    debugLog('CRUD', 'OK Validation passed');

    // Determine endpoint
    const endpoint = id ? 'directorates/update' : 'directorates/create';
    if (id) data.directorate_id = id;

    debugLog('CRUD', 'Calling endpoint: ' + endpoint, data);

    // API call
    const result = await apiCall(endpoint, data);
    debugLog('CRUD', 'API result:', result);

    if (result.success) {
        debugLog('CRUD', 'OK Directorate saved successfully');
        showToast('Directorate saved successfully', 'success');

        // Close modal
        const modalEl = document.getElementById('directorateModal');
        const modal = bootstrap.Modal.getInstance(modalEl);
        if (modal) {
            modal.hide();
            debugLog('CRUD', 'OK Modal closed');
        } else {
            debugLog('CRUD', 'FAIL Failed to get modal instance');
        }

        // Reload data
        debugLog('CRUD', 'Refreshing directorates table...');
        await OrganizationManager.refreshEntityTable('directorate');
        debugLog('CRUD', 'OK Directorates table refreshed');

        // Reload diagram if active
        if (ViewToggle.getCurrentView() === 'diagram' && typeof OrgDiagram !== 'undefined') {
            debugLog('CRUD', 'Reloading diagram after directorate save');
            await OrgDiagram.reload();
        }

        debugLog('CRUD', '=== saveDirectorate COMPLETE ===');
    } else {
        debugLog('CRUD', 'FAIL Failed to save: ' + result.message);
        showToast('Failed to save: ' + result.message, 'error');
    }
}

// Save Work Unit
async function saveWorkUnit() {
    debugLog('CRUD', '=== saveWorkUnit START ===');

    // Get form elements
    const idEl = document.getElementById('work_unit_id');
    const codeEl = document.getElementById('work_unit_code');
    const nameEl = document.getElementById('work_unit_name');
    const directorateEl = document.getElementById('directorate_id_select');

    // Defensive checks
    if (!codeEl || !nameEl || !directorateEl) {
        debugLog('CRUD', 'FAIL: Required form elements not found');
        showToast('Form not properly initialized. Please try again.', 'error');
        return;
    }

    const id = idEl ? idEl.value : '';
    const data = {
        work_unit_code: codeEl.value,
        work_unit_name: nameEl.value,
        directorate_id: directorateEl.value
    };

    const formData = { id: id };
    for (const key in data) {
        formData[key] = data[key];
    }
    debugLog('CRUD', 'Form data:', formData);

    if (!data.work_unit_code || !data.work_unit_name || !data.directorate_id) {
        debugLog('CRUD', 'FAIL Validation failed: missing required fields');
        showToast('Please fill in all required fields', 'error');
        return;
    }
    debugLog('CRUD', 'OK Validation passed');

    const endpoint = id ? 'work-units/update' : 'work-units/create';
    if (id) data.work_unit_id = id;

    debugLog('CRUD', 'Calling endpoint: ' + endpoint, data);
    const result = await apiCall(endpoint, data);
    debugLog('CRUD', 'API result:', result);

    if (result.success) {
        debugLog('CRUD', 'OK Work Unit saved successfully');
        showToast('Work Unit saved successfully', 'success');

        const modalEl = document.getElementById('work-unitModal');
        const modal = bootstrap.Modal.getInstance(modalEl);
        if (modal) {
            modal.hide();
            debugLog('CRUD', 'OK Modal closed');
        }

        await OrganizationManager.refreshEntityTable('work-unit');
        debugLog('CRUD', 'OK Work Units table refreshed');

        // Reload diagram if active
        if (ViewToggle.getCurrentView() === 'diagram' && typeof OrgDiagram !== 'undefined') {
            debugLog('CRUD', 'Reloading diagram after work unit save');
            await OrgDiagram.reload();
        }

        debugLog('CRUD', '=== saveWorkUnit COMPLETE ===');
    } else {
        debugLog('CRUD', 'FAIL Failed to save: ' + result.message);
        showToast('Failed to save: ' + result.message, 'error');
    }
}

// Save Affair
async function saveAffair() {
    debugLog('CRUD', '=== saveAffair START ===');

    // Get form elements
    const idEl = document.getElementById('affair_id');
    const codeEl = document.getElementById('affair_code');
    const nameEl = document.getElementById('affair_name');
    const workUnitEl = document.getElementById('work_unit_id_select');

    // Defensive checks
    if (!codeEl || !nameEl || !workUnitEl) {
        debugLog('CRUD', 'FAIL: Required form elements not found');
        showToast('Form not properly initialized. Please try again.', 'error');
        return;
    }

    const id = idEl ? idEl.value : '';
    const data = {
        affair_code: codeEl.value,
        affair_name: nameEl.value,
        work_unit_id: workUnitEl.value
    };

    const formData = { id: id };
    for (const key in data) {
        formData[key] = data[key];
    }
    debugLog('CRUD', 'Form data:', formData);

    if (!data.affair_code || !data.affair_name || !data.work_unit_id) {
        debugLog('CRUD', 'FAIL Validation failed: missing required fields');
        showToast('Please fill in all required fields', 'error');
        return;
    }
    debugLog('CRUD', 'OK Validation passed');

    const endpoint = id ? 'affairs/update' : 'affairs/create';
    if (id) data.affair_id = id;

    debugLog('CRUD', 'Calling endpoint: ' + endpoint, data);
    const result = await apiCall(endpoint, data);
    debugLog('CRUD', 'API result:', result);

    if (result.success) {
        debugLog('CRUD', 'OK Affair saved successfully');
        showToast('Affair saved successfully', 'success');

        const modalEl = document.getElementById('affairModal');
        const modal = bootstrap.Modal.getInstance(modalEl);
        if (modal) {
            modal.hide();
            debugLog('CRUD', 'OK Modal closed');
        }

        await OrganizationManager.refreshEntityTable('affair');
        debugLog('CRUD', 'OK Affairs table refreshed');

        // Reload diagram if active
        if (ViewToggle.getCurrentView() === 'diagram' && typeof OrgDiagram !== 'undefined') {
            debugLog('CRUD', 'Reloading diagram after affair save');
            await OrgDiagram.reload();
        }

        debugLog('CRUD', '=== saveAffair COMPLETE ===');
    } else {
        debugLog('CRUD', 'FAIL Failed to save: ' + result.message);
        showToast('Failed to save: ' + result.message, 'error');
    }
}

// Save Position
async function savePosition() {
    debugLog('CRUD', '=== savePosition START ===');

    // Get form elements
    const idEl = document.getElementById('position_id');
    const codeEl = document.getElementById('position_code');
    const nameEl = document.getElementById('position_name');
    const levelEl = document.getElementById('position_level');
    const workUnitEl = document.getElementById('position_work_unit_id_select');

    // Defensive checks
    if (!codeEl || !nameEl || !levelEl || !workUnitEl) {
        debugLog('CRUD', 'FAIL: Required form elements not found');
        showToast('Form not properly initialized. Please try again.', 'error');
        return;
    }

    const id = idEl ? idEl.value : '';
    const data = {
        position_code: codeEl.value,
        position_name: nameEl.value,
        position_level: levelEl.value,
        work_unit_id: workUnitEl.value
    };

    const formData = { id: id };
    for (const key in data) {
        formData[key] = data[key];
    }
    debugLog('CRUD', 'Form data:', formData);

    if (!data.position_code || !data.position_name || !data.work_unit_id) {
        debugLog('CRUD', 'FAIL Validation failed: missing required fields');
        showToast('Please fill in all required fields', 'error');
        return;
    }
    debugLog('CRUD', 'OK Validation passed');

    const endpoint = id ? 'positions/update' : 'positions/create';
    if (id) data.position_id = id;

    debugLog('CRUD', 'Calling endpoint: ' + endpoint, data);
    const result = await apiCall(endpoint, data);
    debugLog('CRUD', 'API result:', result);

    if (result.success) {
        debugLog('CRUD', 'OK Position saved successfully');
        showToast('Position saved successfully', 'success');

        const modalEl = document.getElementById('positionModal');
        const modal = bootstrap.Modal.getInstance(modalEl);
        if (modal) {
            modal.hide();
            debugLog('CRUD', 'OK Modal closed');
        }

        await OrganizationManager.refreshEntityTable('position');
        debugLog('CRUD', 'OK Positions table refreshed');

        // Reload diagram if active
        if (ViewToggle.getCurrentView() === 'diagram' && typeof OrgDiagram !== 'undefined') {
            debugLog('CRUD', 'Reloading diagram after position save');
            await OrgDiagram.reload();
        }

        debugLog('CRUD', '=== savePosition COMPLETE ===');
    } else {
        debugLog('CRUD', 'FAIL Failed to save: ' + result.message);
        showToast('Failed to save: ' + result.message, 'error');
    }
}

// ============================================================================
// ENHANCED DELETE CONFIRMATION
// Handles delete operations with children checking and cascade/reassign options
// ============================================================================

// Store current delete operation context
let deleteContext = {
    type: null,
    id: null,
    name: null,
    children: null,
    alternatives: null
};

// Map entity types to API endpoints
const deleteEndpointMap = {
    'directorate': {
        checkChildren: 'directorates/check-children',
        getAlternatives: 'directorates/get-alternatives',
        deleteCascade: 'directorates/delete-cascade',
        deleteReassign: 'directorates/delete-reassign',
        deleteDirect: 'directorates/delete',
        idField: 'directorate_id',
        newNameField: 'new_directorate_id'
    },
    'work-unit': {
        checkChildren: 'work-units/check-children',
        getAlternatives: 'work-units/get-alternatives',
        deleteCascade: 'work-units/delete-cascade',
        deleteReassign: 'work-units/delete-reassign',
        deleteDirect: 'work-units/delete',
        idField: 'work_unit_id',
        newNameField: 'new_work_unit_id'
    },
    'affair': {
        checkChildren: 'affairs/check-children',
        getAlternatives: 'affairs/get-alternatives',
        deleteCascade: 'affairs/delete-cascade',
        deleteReassign: 'affairs/delete-reassign',
        deleteDirect: 'affairs/delete',
        idField: 'affair_id',
        newNameField: 'new_affair_id'
    },
    'position': {
        deleteDirect: 'positions/delete',
        idField: 'position_id'
    }
};

// Helper functions for loading - always use overlay approach
function showDeleteLoading(caller = 'unknown') {
    debugLog('DELETE', 'showDeleteLoading called by: ' + caller);

    // Always use overlay approach (never replace main content for delete operations)
    const existingOverlay = document.querySelector('.delete-loading-overlay');
    if (existingOverlay) {
        debugLog('DELETE', 'Loading overlay already exists, reusing it');
        return;
    }

    const overlay = document.createElement('div');
    overlay.className = 'delete-loading-overlay';
    overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.3);display:flex;align-items:center;justify-content:center;z-index:9999;';
    overlay.innerHTML = '<div class="spinner-border text-primary" role="status" style="width: 3rem; height: 3rem;"><span class="visually-hidden">Loading...</span></div>';
    document.body.appendChild(overlay);
    debugLog('DELETE', 'Loading overlay created');
}

function hideDeleteLoading(caller = 'unknown') {
    debugLog('DELETE', 'hideDeleteLoading called by: ' + caller);

    const overlay = document.querySelector('.delete-loading-overlay');
    if (overlay) {
        overlay.remove();
        debugLog('DELETE', 'Loading overlay removed');
    } else {
        debugLog('DELETE', 'No loading overlay found to remove');
    }
}

// Enhanced delete function
window.deleteItem = async function(type, id) {
    debugLog('DELETE', '=== deleteItem START === type=' + type + ', id=' + id);

    // For positions, use direct delete (no children)
    if (type === 'position') {
        const itemName = type.charAt(0).toUpperCase() + type.slice(1);
        if (!confirm('Are you sure you want to delete this ' + itemName + '?')) {
            debugLog('DELETE', 'FAIL Delete cancelled by user');
            return;
        }

        const endpoint = deleteEndpointMap[type].deleteDirect;
        const result = await apiCall(endpoint, { id });
        debugLog('DELETE', 'API result:', result);

        if (result.success) {
            showToast(itemName + ' deleted successfully', 'success');
            await OrganizationManager.refreshEntityTable(type);
            debugLog('DELETE', 'OK Delete completed');
        } else {
            showToast('Failed to delete: ' + result.message, 'error');
        }
        return;
    }

    // For entities with potential children, check first
    const endpoints = deleteEndpointMap[type];
    showDeleteLoading('deleteItem');

    try {
        // Check for children
        debugLog('DELETE', 'Checking children for ' + type + ' ' + id);
        const childrenResult = await apiCall(endpoints.checkChildren, { [endpoints.idField]: id });
        debugLog('DELETE', 'Children check result:', childrenResult);

        if (!childrenResult.success) {
            hideDeleteLoading('deleteItem-childrenCheckFailed');
            showToast('Failed to check children: ' + childrenResult.message, 'error');
            return;
        }

        const children = childrenResult.data;
        debugLog('DELETE', 'Children data:', children);

        // Get item details for display
        const itemEndpoint = type === 'directorate' ? 'directorates/get' :
                             type === 'work-unit' ? 'work-units/get' :
                             type === 'affair' ? 'affairs/get' : 'positions/get';
        const itemResult = await apiCall(itemEndpoint, { id });
        const itemName = itemResult.success ?
            (itemResult.data.directorate_name || itemResult.data.work_unit_name || itemResult.data.affair_name || type) :
            type;

        // Store context
        deleteContext = {
            type: type,
            id: id,
            name: itemName,
            children: children,
            alternatives: null
        };

        hideDeleteLoading('deleteItem-gotItemDetails');

        // If no children, show simple confirmation
        if (!children.hasChildren) {
            showSimpleDeleteConfirm(type, itemName, id);
        } else {
            // Has children - get alternatives and show full modal
            showDeleteWithChildren(type, itemName, children, id);
        }

    } catch (error) {
        hideDeleteLoading('deleteItem-error');
        debugLog('DELETE', 'FAIL Error: ' + error.message);
        showToast('Error checking children: ' + error.message, 'error');
    }
}

// Show simple delete confirmation (no children)
function showSimpleDeleteConfirm(type, itemName, id) {
    debugLog('DELETE', 'Showing simple delete confirm for ' + itemName);

    // Set up modal content
    document.getElementById('deleteConfirmTitle').textContent = 'Delete ' + (type.charAt(0).toUpperCase() + type.slice(1));
    document.getElementById('deleteItemName').textContent = itemName;
    document.getElementById('deleteDirectMessage').style.display = 'block';
    document.getElementById('deleteHasChildrenWarning').style.display = 'none';
    document.getElementById('deleteChildrenDetails').style.display = 'none';
    document.getElementById('deleteOptionsSection').style.display = 'none';

    // Set direct delete mode
    deleteContext.mode = 'direct';

    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('deleteConfirmModal'));
    modal.show();
}

// Show delete confirmation with children options
async function showDeleteWithChildren(type, itemName, children, id) {
    debugLog('DELETE', 'Showing delete confirm with children for ' + itemName);

    // Set up modal content
    document.getElementById('deleteConfirmTitle').textContent = 'Delete ' + (type.charAt(0).toUpperCase() + type.slice(1));
    document.getElementById('deleteItemName').textContent = itemName;
    document.getElementById('deleteDirectMessage').style.display = 'none';
    document.getElementById('deleteHasChildrenWarning').style.display = 'block';
    document.getElementById('deleteOptionsSection').style.display = 'block';

    // Update children count and details
    document.getElementById('childrenCount').textContent = children.total;

    const childrenList = document.getElementById('childrenList');
    childrenList.innerHTML = '';

    if (children.workUnits > 0) {
        childrenList.innerHTML += '<li><i class="bi bi-building me-2"></i>' + children.workUnits + ' Work Unit(s)</li>';
    }
    if (children.affairs > 0) {
        childrenList.innerHTML += '<li><i class="bi bi-folder me-2"></i>' + children.affairs + ' Affair(s)</li>';
    }
    if (children.positions > 0) {
        childrenList.innerHTML += '<li><i class="bi bi-person me-2"></i>' + children.positions + ' Position(s)</li>';
    }

    document.getElementById('deleteChildrenDetails').style.display = childrenList.innerHTML !== '' ? 'block' : 'none';

    // Get alternatives for reassign option
    const endpointMap = deleteEndpointMap[type];
    showDeleteLoading('showDeleteWithChildren');

    try {
        const alternativesResult = await apiCall(endpointMap.getAlternatives, { [endpointMap.idField]: id });
        debugLog('DELETE', 'Alternatives result:', alternativesResult);
        debugLog('DELETE', 'Alternatives data type:', typeof alternativesResult.data);
        debugLog('DELETE', 'Alternatives data length:', Array.isArray(alternativesResult.data) ? alternativesResult.data.length : 'not an array');

        if (alternativesResult.success) {
            // Handle different data structures
            let alternativesData = alternativesResult.data;

            // If data is not an array, check if it has a nested property
            if (!Array.isArray(alternativesData)) {
                debugLog('DELETE', 'Data is not an array, checking for nested properties');
                if (alternativesData.alternatives && Array.isArray(alternativesData.alternatives)) {
                    alternativesData = alternativesData.alternatives;
                    debugLog('DELETE', 'Found nested alternatives array');
                } else if (alternativesData.work_units && Array.isArray(alternativesData.work_units)) {
                    alternativesData = alternativesData.work_units;
                    debugLog('DELETE', 'Found work_units array');
                } else if (alternativesData.directorates && Array.isArray(alternativesData.directorates)) {
                    alternativesData = alternativesData.directorates;
                    debugLog('DELETE', 'Found directorates array');
                } else {
                    debugLog('DELETE', 'No array found in response, converting to array');
                    alternativesData = alternativesData.data ? [alternativesData.data] : [];
                }
            }

            debugLog('DELETE', 'Processed alternatives data:', alternativesData);
            debugLog('DELETE', 'Alternatives count:', alternativesData.length);

            if (alternativesData.length > 0) {
                deleteContext.alternatives = alternativesData;

                // Populate reassign dropdown with flexible field mapping
                const reassignSelect = document.getElementById('reassignTarget');

                // Destroy existing Select2 if present
                if (typeof $ !== 'undefined' && $(reassignSelect).data('select2')) {
                    $(reassignSelect).select2('destroy');
                }

                reassignSelect.innerHTML = '<option value="">-- Select new parent --</option>';

                alternativesData.forEach(alt => {
                    // Try different field names for id
                    const id = alt.id || alt.work_unit_id || alt.directorate_id || alt.affair_id || alt.position_id;
                    // Try different field names for display name
                    const display = alt.display || alt.name || alt.work_unit_name || alt.directorate_name || alt.affair_name || alt.position_name || alt.title || id;

                    debugLog('DELETE', 'Processing alternative: id=' + id + ', display=' + display);

                    if (id) {
                        reassignSelect.innerHTML += '<option value="' + id + '">' + display + '</option>';
                    }
                });

                // Initialize Select2 on the dropdown for searchable functionality
                if (typeof $ !== 'undefined') {
                    $(reassignSelect).select2({
                        dropdownParent: $('#deleteConfirmModal'),
                        placeholder: '-- Select new parent --',
                        allowClear: true,
                        width: '100%'
                    });
                    debugLog('DELETE', 'Select2 initialized on reassignTarget');
                }

                // Enable reassign option
                document.getElementById('deleteOptionReassign').disabled = false;
                debugLog('DELETE', 'Reassign option enabled with ' + alternativesData.length + ' alternatives');
            } else {
                // No alternatives available, disable reassign option
                deleteContext.alternatives = [];
                document.getElementById('reassignTarget').innerHTML = '<option value="">-- No alternatives available --</option>';
                document.getElementById('deleteOptionReassign').disabled = true;
                document.getElementById('deleteOptionCascade').checked = true;
                debugLog('DELETE', 'No alternatives found, reassign disabled');
            }
        } else {
            // API call failed
            deleteContext.alternatives = [];
            document.getElementById('reassignTarget').innerHTML = '<option value="">-- Error loading alternatives --</option>';
            document.getElementById('deleteOptionReassign').disabled = true;
            document.getElementById('deleteOptionCascade').checked = true;
            debugLog('DELETE', 'Alternatives API call failed: ' + alternativesResult.message);
        }

        hideDeleteLoading('showDeleteWithChildren-gotAlternatives');

        // Set cascade delete as default
        deleteContext.mode = 'cascade';

        // Show modal
        const modal = new bootstrap.Modal(document.getElementById('deleteConfirmModal'));
        modal.show();

    } catch (error) {
        hideDeleteLoading('showDeleteWithChildren-error');
        debugLog('DELETE', 'FAIL Error getting alternatives: ' + error.message);
        showToast('Error getting alternatives: ' + error.message, 'error');
    }
}

// Handle delete option change
function setupDeleteOptionHandlers() {
    if (organizationCrudHandlersSetup) {
        debugLog('DELETE', 'Handlers already setup, skipping');
        return;
    }

    document.addEventListener('change', function deleteOptionHandler(e) {
        if (e.target.name === 'deleteOption') {
            const reassignSection = document.getElementById('reassignSection');
            if (!reassignSection) return;

            if (e.target.value === 'reassign') {
                reassignSection.style.display = 'block';
                deleteContext.mode = 'reassign';
            } else {
                reassignSection.style.display = 'none';
                deleteContext.mode = 'cascade';
            }
        }
    });

    // Hide loading overlay when delete modal is closed (cancel or X button)
    document.addEventListener('hidden.bs.modal', function modalCloseHandler(e) {
        if (e.target.id === 'deleteConfirmModal') {
            // Clean up Select2
            const reassignSelect = document.getElementById('reassignTarget');
            if (reassignSelect && typeof $ !== 'undefined' && $(reassignSelect).data('select2')) {
                $(reassignSelect).select2('destroy');
                debugLog('DELETE', 'Select2 destroyed on modal close');
            }
            hideDeleteLoading('modalClosed');
        }
    });

    organizationCrudHandlersSetup = true;
    debugLog('DELETE', 'Delete option handlers setup complete');
}

// Setup handlers when script loads
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupDeleteOptionHandlers);
} else {
    setupDeleteOptionHandlers();
}

// Execute the delete operation
window.executeDelete = async function() {
    debugLog('DELETE', '=== executeDelete START === mode=' + deleteContext.mode);

    const type = deleteContext.type;
    const id = deleteContext.id;
    const endpoints = deleteEndpointMap[type];

    // Validate reassign option if selected
    if (deleteContext.mode === 'reassign') {
        const newParentId = document.getElementById('reassignTarget').value;
        if (!newParentId) {
            showToast('Please select a new parent for reassignment', 'error');
            return;
        }
        deleteContext.newParentId = newParentId;
    }

    // Close modal
    const modalEl = document.getElementById('deleteConfirmModal');
    const modal = bootstrap.Modal.getInstance(modalEl);
    if (modal) modal.hide();

    showDeleteLoading('executeDelete');

    try {
        let result;
        let endpoint;
        let data = { [endpoints.idField]: id };

        if (deleteContext.mode === 'cascade') {
            endpoint = endpoints.deleteCascade;
            debugLog('DELETE', 'Calling cascade delete: ' + endpoint, data);
            result = await apiCall(endpoint, data);
        } else if (deleteContext.mode === 'reassign') {
            endpoint = endpoints.deleteReassign;
            data[endpoints.newNameField] = deleteContext.newParentId;
            debugLog('DELETE', 'Calling reassign and delete: ' + endpoint, data);
            result = await apiCall(endpoint, data);
        } else {
            // Direct delete (no children)
            endpoint = endpoints.deleteDirect;
            debugLog('DELETE', 'Calling direct delete: ' + endpoint, data);
            result = await apiCall(endpoint, data);
        }

        debugLog('DELETE', 'API result:', result);

        if (result.success) {
            const typeName = type.charAt(0).toUpperCase() + type.slice(1);
            showToast(typeName + ' deleted successfully', 'success');

            // Refresh all affected tables based on entity hierarchy
            // Mapping of entity types to tables that need to be refreshed
            const affectedTables = {
                'directorate': ['directorate', 'work-unit', 'affair', 'position'],
                'work-unit': ['work-unit', 'affair', 'position'],
                'affair': ['affair', 'position'],
                'position': ['position']
            };

            const tablesToRefresh = affectedTables[type] || [type];
            debugLog('DELETE', 'Refreshing affected tables:', tablesToRefresh);

            // Refresh all affected tables in parallel
            const refreshPromises = tablesToRefresh.map(tableType => {
                return OrganizationManager.refreshEntityTable(tableType)
                    .then(() => debugLog('DELETE', 'OK Refreshed ' + tableType + ' table'))
                    .catch(err => debugLog('DELETE', 'FAIL Failed to refresh ' + tableType + ':', err));
            });

            await Promise.all(refreshPromises);
            debugLog('DELETE', 'OK All affected tables refreshed');

            // Reload diagram if active
            if (currentView === 'diagram' && typeof OrgDiagram !== 'undefined') {
                debugLog('DELETE', 'Reloading diagram after delete');
                await OrgDiagram.reload();
            }
        } else {
            showToast('Failed to delete: ' + result.message, 'error');
        }

    } catch (error) {
        debugLog('DELETE', 'FAIL Error: ' + error.message);
        showToast('Error deleting: ' + error.message, 'error');
    } finally {
        hideDeleteLoading('executeDelete-finally');
        debugLog('DELETE', '=== executeDelete COMPLETE ===');
    }
}

// Track script loading
if (window.scriptLoadTracker) {
    window.scriptLoadTracker.loaded('organization_crud.html');
}
</script>
