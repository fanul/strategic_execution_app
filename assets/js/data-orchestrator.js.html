<script>
/**
 * Data Orchestrator for Strategic Execution Monitoring Application
 * Centralized data loading with caching, preloading states, and error handling
 *
 * Features:
 * - Consolidates all data loading operations
 * - Shows preloading state while all data is loading
 * - Caches loaded data for faster subsequent loads
 * - Prevents duplicate requests
 * - Handles errors gracefully
 * - Provides progress updates
 */

// ============================================================================
// DATA ORCHESTRATOR CLASS
// ============================================================================

class DataOrchestrator {
    constructor() {
        // Cache storage with timestamps
        this.cache = new Map();

        // Default cache timeout: 5 minutes
        this.cacheTimeout = 5 * 60 * 1000;

        // Track loading states
        this.loadingStates = new Map();

        // Track ongoing requests (prevent duplicates)
        this.pendingRequests = new Map();

        // Progress callbacks
        this.progressCallbacks = [];

        // Error callbacks
        this.errorCallbacks = [];

        // Data group definitions
        this.dataGroups = this._defineDataGroups();
    }

    // ========================================================================
    // DATA GROUP DEFINITIONS
    // ========================================================================

    /**
     * Define all data groups that can be loaded together
     * @private
     */
    _defineDataGroups() {
        return {
            // Core application data
            'core': {
                name: 'Core Application Data',
                dataTypes: ['currentUser', 'settings', 'permissions'],
                priority: 'high',
                cacheTimeout: 10 * 60 * 1000 // 10 minutes
            },

            // Dashboard data
            'dashboard': {
                name: 'Dashboard Data',
                dataTypes: ['executiveStats', 'recentActivities', 'upcomingDeadlines'],
                priority: 'high',
                cacheTimeout: 2 * 60 * 1000 // 2 minutes
            },

            // Organization data
            'organization': {
                name: 'Organization Data',
                dataTypes: ['directorates', 'workUnits', 'affairs', 'positions', 'positionAssignments'],
                priority: 'medium',
                cacheTimeout: 10 * 60 * 1000
            },

            // Strategic planning data
            'strategic': {
                name: 'Strategic Planning Data',
                dataTypes: ['periods', 'visions', 'missions', 'initiatives', 'goals'],
                priority: 'medium',
                cacheTimeout: 10 * 60 * 1000
            },

            // KPI data
            'kpi': {
                name: 'KPI Data',
                dataTypes: ['organizationalKPIs', 'individualKPIs', 'kpiProgress'],
                priority: 'medium',
                cacheTimeout: 5 * 60 * 1000
            },

            // Program data
            'programs': {
                name: 'Program Data',
                dataTypes: ['programs', 'activities', 'programKPIs'],
                priority: 'medium',
                cacheTimeout: 5 * 60 * 1000
            },

            // OKR data
            'okr': {
                name: 'OKR Data',
                dataTypes: ['myOKRs', 'teamOKRs'],
                priority: 'low',
                cacheTimeout: 2 * 60 * 1000
            },

            // Impact center data
            'impactCenters': {
                name: 'Impact Center Data',
                dataTypes: ['impactCenters', 'icProgress', 'icWorkUnits'],
                priority: 'medium',
                cacheTimeout: 5 * 60 * 1000
            },

            // User management data
            'users': {
                name: 'User Management Data',
                dataTypes: ['users', 'roles'],
                priority: 'low',
                cacheTimeout: 10 * 60 * 1000
            },

            // Reports data
            'reports': {
                name: 'Reports Data',
                dataTypes: ['reportData'],
                priority: 'low',
                cacheTimeout: 15 * 60 * 1000 // 15 minutes
            }
        };
    }

    // ========================================================================
    // DATA LOADERS
    // ========================================================================

    /**
     * Data loader functions for each data type
     * @private
     */
    _dataLoaders = {
        // Core data
        currentUser: async () => {
            const response = await api.auth.me();
            return response.success ? response.data : null;
        },

        settings: async () => {
            const response = await api.settings.getAll();
            return response.success ? response.data : {};
        },

        permissions: async () => {
            // Permissions are included in user data
            const response = await api.auth.me();
            return response.success && response.data ? response.data.permissions : {};
        },

        // Dashboard data
        executiveStats: async () => {
            const response = await api.dashboard.getExecutiveData();
            return response.success ? response.data : null;
        },

        recentActivities: async () => {
            const response = await api.dashboard.getRecentActivities(10);
            return response.success ? response.data : [];
        },

        upcomingDeadlines: async () => {
            const response = await api.dashboard.getRecentActivities(20);
            return response.success ? response.data.filter(a => a.deadline) : [];
        },

        // Organization data
        directorates: async () => {
            const response = await api.directorates.list();
            return response.success ? response.data : [];
        },

        workUnits: async () => {
            const response = await api.workUnits.list();
            return response.success ? response.data : [];
        },

        affairs: async () => {
            const response = await api.affairs.list();
            return response.success ? response.data : [];
        },

        positions: async () => {
            const response = await api.positions.list();
            return response.success ? response.data : [];
        },

        positionAssignments: async () => {
            const response = await api.positionAssignments.list();
            return response.success ? response.data : [];
        },

        // Strategic planning data
        periods: async () => {
            const response = await api.periods.list();
            return response.success ? response.data : [];
        },

        visions: async () => {
            const response = await api.visions.list();
            return response.success ? response.data : [];
        },

        missions: async () => {
            const response = await api.missions.list();
            return response.success ? response.data : [];
        },

        initiatives: async () => {
            const response = await api.initiatives.list();
            return response.success ? response.data : [];
        },

        goals: async () => {
            const response = await api.goals.list();
            return response.success ? response.data : [];
        },

        // KPI data
        organizationalKPIs: async () => {
            const response = await api.kpis.list();
            return response.success ? response.data : [];
        },

        individualKPIs: async () => {
            const response = await api.kpis.individual.list();
            return response.success ? response.data : [];
        },

        kpiProgress: async () => {
            const response = await api.dashboard.getKPIData();
            return response.success ? response.data : {};
        },

        // Program data
        programs: async () => {
            const response = await api.programs.list();
            return response.success ? response.data : [];
        },

        activities: async () => {
            const response = await api.programs.activities.list();
            return response.success ? response.data : [];
        },

        programKPIs: async () => {
            // This would be a combined endpoint
            const response = await api.kpis.list();
            return response.success ? response.data : [];
        },

        // OKR data
        myOKRs: async () => {
            const response = await api.okrs.getMyOKRs();
            return response.success ? response.data : [];
        },

        teamOKRs: async () => {
            const response = await api.okrs.getTeamOKRs();
            return response.success ? response.data : [];
        },

        // Impact center data
        impactCenters: async () => {
            const response = await api.impactCenters.list();
            return response.success ? response.data : [];
        },

        icProgress: async () => {
            const response = await api.dashboard.getImpactCenterData();
            return response.success ? response.data : {};
        },

        icWorkUnits: async () => {
            // This would be a combined endpoint
            const response = await api.workUnits.list();
            return response.success ? response.data : [];
        },

        // User management data
        users: async () => {
            const response = await api.users.list();
            return response.success ? response.data : [];
        },

        roles: async () => {
            const response = await api.roles.list();
            return response.success ? response.data : [];
        },

        // Reports data
        reportData: async () => {
            const response = await api.dashboard.getExecutiveData();
            return response.success ? response.data : {};
        }
    };

    // ========================================================================
    // PUBLIC METHODS
    // ========================================================================

    /**
     * Load a data group
     * @param {string} groupName - Name of the data group to load
     * @param {object} options - Loading options
     * @returns {Promise<object>} Loaded data
     */
    async loadGroup(groupName, options = {}) {
        const {
            forceRefresh = false,
            showProgress = true,
            onError = null
        } = options;

        const group = this.dataGroups[groupName];
        if (!group) {
            throw new Error(`Unknown data group: ${groupName}`);
        }

        // Check if already loading
        if (this.loadingStates.has(groupName)) {
            console.log(`[DataOrchestrator] ${groupName} is already loading, waiting...`);
            return this.loadingStates.get(groupName);
        }

        // Create loading promise
        const loadingPromise = this._loadDataGroup(group, forceRefresh, showProgress);
        this.loadingStates.set(groupName, loadingPromise);

        try {
            const result = await loadingPromise;
            return result;
        } catch (error) {
            if (onError) {
                onError(error);
            } else {
                this._notifyError(error, groupName);
            }
            throw error;
        } finally {
            this.loadingStates.delete(groupName);
        }
    }

    /**
     * Load multiple data groups
     * @param {Array<string>} groupNames - Array of group names to load
     * @param {object} options - Loading options
     * @returns {Promise<object>} Object with all loaded data
     */
    async loadGroups(groupNames, options = {}) {
        const {
            forceRefresh = false,
            showProgress = true,
            parallel = true
        } = options;

        if (showProgress) {
            this._showPreloader();
        }

        try {
            let results;

            if (parallel) {
                // Load all groups in parallel
                const promises = groupNames.map(name =>
                    this.loadGroup(name, { forceRefresh, showProgress: false })
                );
                results = await Promise.all(promises);
            } else {
                // Load groups sequentially
                results = [];
                for (const name of groupNames) {
                    const result = await this.loadGroup(name, { forceRefresh, showProgress: false });
                    results.push(result);
                }
            }

            // Combine results
            const combined = {};
            groupNames.forEach((name, index) => {
                combined[name] = results[index];
            });

            return combined;

        } finally {
            if (showProgress) {
                this._hidePreloader();
            }
        }
    }

    /**
     * Load all data for a specific view
     * @param {string} viewName - Name of the view
     * @param {object} options - Loading options
     * @returns {Promise<object>} View data
     */
    async loadView(viewName, options = {}) {
        const viewDataMap = {
            'dashboard': ['dashboard', 'core'],
            'organization': ['organization', 'core'],
            'strategic-plan': ['strategic', 'core'],
            'kpi': ['kpi', 'organization', 'core'],
            'okr': ['okr', 'core'],
            'programs': ['programs', 'kpi', 'core'],
            'impact-centers': ['impactCenters', 'strategic', 'core'],
            'reports': ['reports', 'dashboard', 'core'],
            'users': ['users', 'organization', 'core']
        };

        const groups = viewDataMap[viewName] || ['core'];
        return this.loadGroups(groups, options);
    }

    /**
     * Get cached data
     * @param {string} dataType - Data type to get from cache
     * @returns {any|null} Cached data or null
     */
    getCached(dataType) {
        const cached = this.cache.get(dataType);
        if (cached && Date.now() - cached.timestamp < cached.timeout) {
            return cached.data;
        }
        return null;
    }

    /**
     * Clear cache
     * @param {string|null} dataType - Data type to clear, or null to clear all
     */
    clearCache(dataType = null) {
        if (dataType) {
            this.cache.delete(dataType);
        } else {
            this.cache.clear();
        }
        console.log('[DataOrchestrator] Cache cleared');
    }

    /**
     * Refresh a data group
     * @param {string} groupName - Group name to refresh
     * @returns {Promise<object>} Refreshed data
     */
    async refresh(groupName) {
        return this.loadGroup(groupName, { forceRefresh: true });
    }

    // ========================================================================
    // INTERNAL METHODS
    // ========================================================================

    /**
     * Load a data group internally
     * @private
     */
    async _loadDataGroup(group, forceRefresh, showProgress) {
        const result = {};
        let loadedCount = 0;
        const totalCount = group.dataTypes.length;

        for (const dataType of group.dataTypes) {
            try {
                // Check cache first
                if (!forceRefresh) {
                    const cached = this.getCached(dataType);
                    if (cached !== null) {
                        result[dataType] = cached;
                        loadedCount++;
                        this._notifyProgress(group.name, loadedCount, totalCount, dataType);
                        continue;
                    }
                }

                // Check for pending request
                if (this.pendingRequests.has(dataType)) {
                    result[dataType] = await this.pendingRequests.get(dataType);
                } else {
                    // Load data
                    const loadPromise = this._loadSingleDataType(dataType, group.cacheTimeout);
                    this.pendingRequests.set(dataType, loadPromise);

                    result[dataType] = await loadPromise;
                    this.pendingRequests.delete(dataType);
                }

                loadedCount++;
                this._notifyProgress(group.name, loadedCount, totalCount, dataType);

            } catch (error) {
                console.error(`[DataOrchestrator] Error loading ${dataType}:`, error);
                result[dataType] = null;
            }
        }

        return result;
    }

    /**
     * Load a single data type
     * @private
     */
    async _loadSingleDataType(dataType, cacheTimeout) {
        const loader = this._dataLoaders[dataType];
        if (!loader) {
            throw new Error(`No loader defined for data type: ${dataType}`);
        }

        const data = await loader();

        // Cache the result
        if (data !== null && data !== undefined) {
            this.cache.set(dataType, {
                data: data,
                timestamp: Date.now(),
                timeout: cacheTimeout || this.cacheTimeout
            });
        }

        return data;
    }

    /**
     * Notify progress callbacks
     * @private
     */
    _notifyProgress(groupName, loaded, total, dataType) {
        const progress = {
            group: groupName,
            loaded: loaded,
            total: total,
            percentage: Math.round((loaded / total) * 100),
            current: dataType
        };

        this.progressCallbacks.forEach(callback => {
            try {
                callback(progress);
            } catch (error) {
                console.error('[DataOrchestrator] Progress callback error:', error);
            }
        });
    }

    /**
     * Notify error callbacks
     * @private
     */
    _notifyError(error, groupName) {
        this.errorCallbacks.forEach(callback => {
            try {
                callback(error, groupName);
            } catch (err) {
                console.error('[DataOrchestrator] Error callback error:', err);
            }
        });
    }

    /**
     * Show preloader overlay
     * @private
     */
    _showPreloader() {
        let preloader = document.getElementById('data-preloader');
        if (!preloader) {
            preloader = document.createElement('div');
            preloader.id = 'data-preloader';
            preloader.className = 'data-preloader-overlay';
            preloader.innerHTML = `
                <div class="data-preloader-content">
                    <div class="spinner-border text-primary mb-3" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <div class="preloader-message">Loading application data...</div>
                    <div class="preloader-progress">
                        <div class="progress">
                            <div class="progress-bar progress-bar-striped progress-bar-animated"
                                 role="progressbar"
                                 style="width: 0%"
                                 id="preloader-progress-bar"></div>
                        </div>
                    </div>
                    <div class="preloader-status mt-2 text-muted small"></div>
                </div>
            `;
            document.body.appendChild(preloader);
        }

        preloader.style.display = 'flex';
    }

    /**
     * Hide preloader overlay
     * @private
     */
    _hidePreloader() {
        const preloader = document.getElementById('data-preloader');
        if (preloader) {
            // Fade out
            preloader.style.opacity = '0';
            setTimeout(() => {
                preloader.style.display = 'none';
                preloader.style.opacity = '1';
            }, 300);
        }
    }

    /**
     * Update preloader progress
     * @private
     */
    _updatePreloader(progress) {
        const progressBar = document.getElementById('preloader-progress-bar');
        const statusText = document.querySelector('.preloader-status');

        if (progressBar) {
            progressBar.style.width = `${progress.percentage}%`;
            progressBar.setAttribute('aria-valuenow', progress.percentage);
        }

        if (statusText) {
            statusText.textContent = `Loading ${progress.current}... (${progress.loaded}/${progress.total})`;
        }
    }

    // ========================================================================
    // EVENT HANDLERS
    // ========================================================================

    /**
     * Register progress callback
     * @param {function} callback - Progress callback function
     */
    onProgress(callback) {
        if (typeof callback === 'function') {
            this.progressCallbacks.push(callback);
        }
    }

    /**
     * Register error callback
     * @param {function} callback - Error callback function
     */
    onError(callback) {
        if (typeof callback === 'function') {
            this.errorCallbacks.push(callback);
        }
    }

    /**
     * Remove all callbacks
     */
    removeAllCallbacks() {
        this.progressCallbacks = [];
        this.errorCallbacks = [];
    }
}

// ============================================================================
// CREATE GLOBAL INSTANCE
// ============================================================================

const dataOrchestrator = new DataOrchestrator();

// Make available globally
if (typeof window !== 'undefined') {
    window.DataOrchestrator = DataOrchestrator;
    window.dataOrchestrator = dataOrchestrator;
}

// ============================================================================
// AUTO-SETUP PROGRESS UPDATES
// ============================================================================

// Automatically update preloader when progress changes
dataOrchestrator.onProgress((progress) => {
    dataOrchestrator._updatePreloader(progress);
    console.log(`[DataOrchestrator] ${progress.group}: ${progress.percentage}% - ${progress.current}`);
});

// Log errors automatically
dataOrchestrator.onError((error, groupName) => {
    console.error(`[DataOrchestrator] Error loading ${groupName}:`, error);
});

</script>
