<script>
/**
 * Utility Functions for Strategic Execution Monitoring Application
 * Provides helper functions for date, string formatting, validation, etc.
 */

// ============================================================================
// DATE UTILITIES
// ============================================================================

const DateUtils = {
    /**
     * Format date to display string
     * @param {Date|string} date - Date to format
     * @param {string} format - Format type: 'short', 'long', 'time', 'full'
     * @param {string} locale - Locale code (default: 'id-ID')
     * @returns {string} Formatted date string
     */
    formatDate(date, format = 'short', locale = 'id-ID') {
        if (!date) return '-';
        const d = new Date(date);
        if (isNaN(d.getTime())) return '-';

        const options = {
            'short': { year: 'numeric', month: 'short', day: 'numeric' },
            'long': { year: 'numeric', month: 'long', day: 'numeric' },
            'time': { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' },
            'full': { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' },
            'monthYear': { year: 'numeric', month: 'long' },
            'yearMonth': { year: 'numeric', month: '2-digit' }
        };

        return d.toLocaleDateString(locale, options[format] || options['short']);
    },

    /**
     * Get date range string
     * @param {Date|string} startDate - Start date
     * @param {Date|string} endDate - End date
     * @returns {string} Formatted date range
     */
    getDateRange(startDate, endDate) {
        const start = this.formatDate(startDate, 'short');
        const end = this.formatDate(endDate, 'short');
        return `${start} - ${end}`;
    },

    /**
     * Get week number from date
     * @param {Date} date - Date to get week number for
     * @returns {number} Week number (1-53)
     */
    getWeekNumber(date) {
        const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
        const dayNum = d.getUTCDay() || 7;
        d.setUTCDate(d.getUTCDate() + 4 - dayNum);
        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    },

    /**
     * Get start and end date of week
     * @param {number} year - Year
     * @param {number} week - Week number
     * @returns {object} { startDate: Date, endDate: Date }
     */
    getWeekDates(year, week) {
        const firstDayOfYear = new Date(year, 0, 1);
        const daysToAdd = (week - 1) * 7;
        const startDate = new Date(firstDayOfYear);
        startDate.setDate(firstDayOfYear.getDate() + daysToAdd);

        // Adjust to Monday
        const dayOfWeek = startDate.getDay();
        const diff = startDate.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
        startDate.setDate(diff);

        const endDate = new Date(startDate);
        endDate.setDate(startDate.getDate() + 6);

        return { startDate, endDate };
    },

    /**
     * Get month name
     * @param {number} month - Month number (0-11)
     * @param {string} locale - Locale code
     * @returns {string} Month name
     */
    getMonthName(month, locale = 'id-ID') {
        const date = new Date();
        date.setMonth(month);
        return date.toLocaleDateString(locale, { month: 'long' });
    },

    /**
     * Get quarter from date
     * @param {Date} date - Date to get quarter for
     * @returns {number} Quarter (1-4)
     */
    getQuarter(date) {
        return Math.floor(date.getMonth() / 3) + 1;
    },

    /**
     * Add days to date
     * @param {Date} date - Original date
     * @param {number} days - Days to add
     * @returns {Date} New date
     */
    addDays(date, days) {
        const result = new Date(date);
        result.setDate(result.getDate() + days);
        return result;
    },

    /**
     * Add months to date
     * @param {Date} date - Original date
     * @param {number} months - Months to add
     * @returns {Date} New date
     */
    addMonths(date, months) {
        const result = new Date(date);
        result.setMonth(result.getMonth() + months);
        return result;
    },

    /**
     * Calculate days between two dates
     * @param {Date} startDate - Start date
     * @param {Date} endDate - End date
     * @returns {number} Days between
     */
    daysBetween(startDate, endDate) {
        const oneDay = 24 * 60 * 60 * 1000;
        return Math.round((endDate - startDate) / oneDay);
    },

    /**
     * Check if date is today
     * @param {Date} date - Date to check
     * @returns {boolean}
     */
    isToday(date) {
        const today = new Date();
        return date.getDate() === today.getDate() &&
               date.getMonth() === today.getMonth() &&
               date.getFullYear() === today.getFullYear();
    },

    /**
     * Check if date is in current week
     * @param {Date} date - Date to check
     * @returns {boolean}
     */
    isThisWeek(date) {
        const today = new Date();
        const weekNum = this.getWeekNumber(today);
        return this.getWeekNumber(date) === weekNum && date.getFullYear() === today.getFullYear();
    },

    /**
     * Get relative time string (e.g., "2 days ago")
     * @param {Date} date - Date to compare
     * @returns {string}
     */
    getRelativeTime(date) {
        const now = new Date();
        const diffMs = now - new Date(date);
        const diffSec = Math.floor(diffMs / 1000);
        const diffMin = Math.floor(diffSec / 60);
        const diffHour = Math.floor(diffMin / 60);
        const diffDay = Math.floor(diffHour / 24);

        if (diffSec < 60) return 'just now';
        if (diffMin < 60) return `${diffMin} minute${diffMin > 1 ? 's' : ''} ago`;
        if (diffHour < 24) return `${diffHour} hour${diffHour > 1 ? 's' : ''} ago`;
        if (diffDay < 7) return `${diffDay} day${diffDay > 1 ? 's' : ''} ago`;
        return this.formatDate(date, 'short');
    }
};

// ============================================================================
// STRING UTILITIES
// ============================================================================

const StringUtils = {
    /**
     * Convert string to title case
     * @param {string} str - String to convert
     * @returns {string} Title case string
     */
    toTitleCase(str) {
        if (!str) return '';
        return str.replace(/\w\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());
    },

    /**
     * Convert string to sentence case
     * @param {string} str - String to convert
     * @returns {string} Sentence case string
     */
    toSentenceCase(str) {
        if (!str) return '';
        return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
    },

    /**
     * Convert string to slug
     * @param {string} str - String to convert
     * @returns {string} Slug string
     */
    toSlug(str) {
        if (!str) return '';
        return str
            .toLowerCase()
            .trim()
            .replace(/[^\w\s-]/g, '')
            .replace(/[\s_-]+/g, '-')
            .replace(/^-+|-+$/g, '');
    },

    /**
     * Truncate string with ellipsis
     * @param {string} str - String to truncate
     * @param {number} length - Max length
     * @param {string} suffix - Suffix to add (default: '...')
     * @returns {string} Truncated string
     */
    truncate(str, length, suffix = '...') {
        if (!str) return '';
        if (str.length <= length) return str;
        return str.substring(0, length - suffix.length) + suffix;
    },

    /**
     * Generate random string
     * @param {number} length - Length of string
     * @param {string} charset - Characters to use
     * @returns {string} Random string
     */
    random(length = 8, charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789') {
        let result = '';
        for (let i = 0; i < length; i++) {
            result += charset.charAt(Math.floor(Math.random() * charset.length));
        }
        return result;
    },

    /**
     * Generate UUID v4
     * @returns {string} UUID
     */
    uuid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    },

    /**
     * Escape HTML special characters
     * @param {string} str - String to escape
     * @returns {string} Escaped string
     */
    escapeHtml(str) {
        if (!str) return '';
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    },

    /**
     * Unescape HTML special characters
     * @param {string} str - String to unescape
     * @returns {string} Unescaped string
     */
    unescapeHtml(str) {
        if (!str) return '';
        const div = document.createElement('div');
        div.innerHTML = str;
        return div.textContent;
    },

    /**
     * Format number with thousands separator
     * @param {number} num - Number to format
     * @param {string} locale - Locale code
     * @returns {string} Formatted number
     */
    formatNumber(num, locale = 'id-ID') {
        if (num === null || num === undefined) return '-';
        return num.toLocaleString(locale);
    },

    /**
     * Format currency
     * @param {number} amount - Amount to format
     * @param {string} currency - Currency code (default: 'IDR')
     * @param {string} locale - Locale code
     * @returns {string} Formatted currency
     */
    formatCurrency(amount, currency = 'IDR', locale = 'id-ID') {
        if (amount === null || amount === undefined) return '-';
        return new Intl.NumberFormat(locale, {
            style: 'currency',
            currency: currency,
            minimumFractionDigits: 0,
            maximumFractionDigits: 0
        }).format(amount);
    },

    /**
     * Format percentage
     * @param {number} value - Value to format
     * @param {number} decimals - Decimal places
     * @returns {string} Formatted percentage
     */
    formatPercentage(value, decimals = 1) {
        if (value === null || value === undefined) return '-';
        return `${value.toFixed(decimals)}%`;
    },

    /**
     * Capitalize first letter
     * @param {string} str - String to capitalize
     * @returns {string} Capitalized string
     */
    capitalize(str) {
        if (!str) return '';
        return str.charAt(0).toUpperCase() + str.slice(1);
    },

    /**
     * Check if string is empty or only whitespace
     * @param {string} str - String to check
     * @returns {boolean}
     */
    isEmpty(str) {
        return !str || str.trim().length === 0;
    },

    /**
     * Pad string with zeros
     * @param {string|number} num - Number to pad
     * @param {number} size - Total size
     * @returns {string} Padded string
     */
    padZero(num, size = 2) {
        let s = num.toString();
        while (s.length < size) s = '0' + s;
        return s;
    },

    /**
     * Split string into array of chunks
     * @param {string} str - String to split
     * @param {number} chunkSize - Size of each chunk
     * @returns {array} Array of chunks
     */
    chunk(str, chunkSize) {
        const chunks = [];
        for (let i = 0; i < str.length; i += chunkSize) {
            chunks.push(str.substring(i, i + chunkSize));
        }
        return chunks;
    },

    /**
     * Highlight search terms in text
     * @param {string} text - Text to highlight
     * @param {string} searchTerm - Term to highlight
     * @returns {string} Text with highlighted terms
     */
    highlight(text, searchTerm) {
        if (!text || !searchTerm) return text;
        const regex = new RegExp(`(${searchTerm})`, 'gi');
        return text.replace(regex, '<mark>$1</mark>');
    },

    /**
     * Convert camelCase to snake_case
     * @param {string} str - String to convert
     * @returns {string} snake_case string
     */
    camelToSnake(str) {
        return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
    },

    /**
     * Convert snake_case to camelCase
     * @param {string} str - String to convert
     * @returns {string} camelCase string
     */
    snakeToCamel(str) {
        return str.replace(/([-_][a-z])/g, group =>
            group.toUpperCase().replace('-', '').replace('_', '')
        );
    },

    /**
     * Parse query string to object
     * @param {string} queryString - Query string
     * @returns {object} Parsed object
     */
    parseQueryString(queryString) {
        const params = {};
        const pairs = queryString.substring(1).split('&');
        pairs.forEach(pair => {
            const [key, value] = pair.split('=');
            params[decodeURIComponent(key)] = decodeURIComponent(value);
        });
        return params;
    },

    /**
     * Build query string from object
     * @param {object} params - Parameters object
     * @returns {string} Query string
     */
    buildQueryString(params) {
        return Object.keys(params)
            .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`)
            .join('&');
    }
};

// ============================================================================
// VALIDATION UTILITIES
// ============================================================================

const ValidationUtils = {
    /**
     * Validate email format
     * @param {string} email - Email to validate
     * @returns {boolean}
     */
    isValidEmail(email) {
        const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return re.test(email);
    },

    /**
     * Validate URL format
     * @param {string} url - URL to validate
     * @returns {boolean}
     */
    isValidUrl(url) {
        try {
            new URL(url);
            return true;
        } catch {
            return false;
        }
    },

    /**
     * Validate phone number (basic)
     * @param {string} phone - Phone number to validate
     * @returns {boolean}
     */
    isValidPhone(phone) {
        const re = /^[\d\s\-+()]+$/;
        return re.test(phone) && phone.replace(/\D/g, '').length >= 10;
    },

    /**
     * Validate password strength
     * @param {string} password - Password to validate
     * @returns {object} { isValid: boolean, strength: string, issues: array }
     */
    validatePassword(password) {
        const issues = [];
        let strength = 'weak';

        if (password.length < 8) issues.push('At least 8 characters');
        if (!/[a-z]/.test(password)) issues.push('Lowercase letter');
        if (!/[A-Z]/.test(password)) issues.push('Uppercase letter');
        if (!/\d/.test(password)) issues.push('Number');
        if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) issues.push('Special character');

        const score = 5 - issues.length;
        if (score >= 4) strength = 'strong';
        else if (score >= 3) strength = 'medium';

        return {
            isValid: issues.length === 0,
            strength,
            issues
        };
    },

    /**
     * Check if value is between min and max
     * @param {number} value - Value to check
     * @param {number} min - Minimum value
     * @param {number} max - Maximum value
     * @returns {boolean}
     */
    isBetween(value, min, max) {
        return value >= min && value <= max;
    },

    /**
     * Check if date range is valid
     * @param {Date} startDate - Start date
     * @param {Date} endDate - End date
     * @returns {boolean}
     */
    isValidDateRange(startDate, endDate) {
        return new Date(startDate) <= new Date(endDate);
    },

    /**
     * Check if percentage is valid (0-100)
     * @param {number} value - Value to check
     * @returns {boolean}
     */
    isValidPercentage(value) {
        return value >= 0 && value <= 100;
    }
};

// ============================================================================
// ARRAY UTILITIES
// ============================================================================

const ArrayUtils = {
    /**
     * Remove duplicates from array
     * @param {array} arr - Array to deduplicate
     * @returns {array} Deduplicated array
     */
    unique(arr) {
        return [...new Set(arr)];
    },

    /**
     * Group array by key
     * @param {array} arr - Array to group
     * @param {string} key - Key to group by
     * @returns {object} Grouped object
     */
    groupBy(arr, key) {
        return arr.reduce((result, item) => {
            const group = item[key];
            result[group] = result[group] || [];
            result[group].push(item);
            return result;
        }, {});
    },

    /**
     * Sort array by key
     * @param {array} arr - Array to sort
     * @param {string} key - Key to sort by
     * @param {string} order - 'asc' or 'desc'
     * @returns {array} Sorted array
     */
    sortBy(arr, key, order = 'asc') {
        return arr.sort((a, b) => {
            if (order === 'asc') return a[key] > b[key] ? 1 : -1;
            return a[key] < b[key] ? 1 : -1;
        });
    },

    /**
     * Chunk array into smaller arrays
     * @param {array} arr - Array to chunk
     * @param {number} size - Chunk size
     * @returns {array} Array of chunks
     */
    chunk(arr, size) {
        const chunks = [];
        for (let i = 0; i < arr.length; i += size) {
            chunks.push(arr.slice(i, i + size));
        }
        return chunks;
    },

    /**
     * Flatten nested array
     * @param {array} arr - Array to flatten
     * @returns {array} Flattened array
     */
    flatten(arr) {
        return arr.flat(Infinity);
    },

    /**
     * Shuffle array
     * @param {array} arr - Array to shuffle
     * @returns {array} Shuffled array
     */
    shuffle(arr) {
        const shuffled = [...arr];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    },

    /**
     * Get random item from array
     * @param {array} arr - Array
     * @returns {*} Random item
     */
    random(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    },

    /**
     * Sum array of numbers
     * @param {array} arr - Array of numbers
     * @returns {number} Sum
     */
    sum(arr) {
        return arr.reduce((sum, val) => sum + val, 0);
    },

    /**
     * Get average of array of numbers
     * @param {array} arr - Array of numbers
     * @returns {number} Average
     */
    average(arr) {
        return arr.length > 0 ? this.sum(arr) / arr.length : 0;
    },

    /**
     * Find item in array by property value
     * @param {array} arr - Array to search
     * @param {string} prop - Property name
     * @param {*} value - Value to match
     * @returns {*} Found item or undefined
     */
    findBy(arr, prop, value) {
        return arr.find(item => item[prop] === value);
    }
};

// ============================================================================
// OBJECT UTILITIES
// ============================================================================

const ObjectUtils = {
    /**
     * Deep clone object
     * @param {object} obj - Object to clone
     * @returns {object} Cloned object
     */
    clone(obj) {
        return JSON.parse(JSON.stringify(obj));
    },

    /**
     * Merge objects
     * @param {object} target - Target object
     * @param {...object} sources - Source objects
     * @returns {object} Merged object
     */
    merge(target, ...sources) {
        return Object.assign({}, target, ...sources);
    },

    /**
     * Get nested property value
     * @param {object} obj - Object
     * @param {string} path - Dot notation path
     * @param {*} defaultValue - Default value if not found
     * @returns {*} Property value or default
     */
    get(obj, path, defaultValue = undefined) {
        const keys = path.split('.');
        let result = obj;
        for (const key of keys) {
            if (result == null) return defaultValue;
            result = result[key];
        }
        return result !== undefined ? result : defaultValue;
    },

    /**
     * Set nested property value
     * @param {object} obj - Object
     * @param {string} path - Dot notation path
     * @param {*} value - Value to set
     * @returns {object} Modified object
     */
    set(obj, path, value) {
        const keys = path.split('.');
        const result = { ...obj };
        let current = result;
        for (let i = 0; i < keys.length - 1; i++) {
            const key = keys[i];
            if (!(key in current)) {
                current[key] = {};
            }
            current = current[key];
        }
        current[keys[keys.length - 1]] = value;
        return result;
    },

    /**
     * Check if object is empty
     * @param {object} obj - Object to check
     * @returns {boolean}
     */
    isEmpty(obj) {
        return Object.keys(obj).length === 0;
    },

    /**
     * Pick specific keys from object
     * @param {object} obj - Source object
     * @param {array} keys - Keys to pick
     * @returns {object} Object with picked keys
     */
    pick(obj, keys) {
        return keys.reduce((result, key) => {
            if (key in obj) result[key] = obj[key];
            return result;
        }, {});
    },

    /**
     * Omit specific keys from object
     * @param {object} obj - Source object
     * @param {array} keys - Keys to omit
     * @returns {object} Object without omitted keys
     */
    omit(obj, keys) {
        const result = { ...obj };
        keys.forEach(key => delete result[key]);
        return result;
    },

    /**
     * Convert object to query string
     * @param {object} obj - Object to convert
     * @returns {string} Query string
     */
    toQueryString(obj) {
        return Object.keys(obj)
            .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(obj[key])}`)
            .join('&');
    }
};

// ============================================================================
// STORAGE UTILITIES
// ============================================================================

const StorageUtils = {
    /**
     * Save to localStorage
     * @param {string} key - Storage key
     * @param {*} value - Value to store
     */
    save(key, value) {
        try {
            localStorage.setItem(key, JSON.stringify(value));
        } catch (e) {
            console.error('Error saving to localStorage:', e);
        }
    },

    /**
     * Get from localStorage
     * @param {string} key - Storage key
     * @param {*} defaultValue - Default value if not found
     * @returns {*} Stored value or default
     */
    get(key, defaultValue = null) {
        try {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : defaultValue;
        } catch (e) {
            console.error('Error reading from localStorage:', e);
            return defaultValue;
        }
    },

    /**
     * Remove from localStorage
     * @param {string} key - Storage key
     */
    remove(key) {
        try {
            localStorage.removeItem(key);
        } catch (e) {
            console.error('Error removing from localStorage:', e);
        }
    },

    /**
     * Clear all localStorage
     */
    clear() {
        try {
            localStorage.clear();
        } catch (e) {
            console.error('Error clearing localStorage:', e);
        }
    },

    /**
     * Save to sessionStorage
     * @param {string} key - Storage key
     * @param {*} value - Value to store
     */
    saveSession(key, value) {
        try {
            sessionStorage.setItem(key, JSON.stringify(value));
        } catch (e) {
            console.error('Error saving to sessionStorage:', e);
        }
    },

    /**
     * Get from sessionStorage
     * @param {string} key - Storage key
     * @param {*} defaultValue - Default value if not found
     * @returns {*} Stored value or default
     */
    getSession(key, defaultValue = null) {
        try {
            const item = sessionStorage.getItem(key);
            return item ? JSON.parse(item) : defaultValue;
        } catch (e) {
            console.error('Error reading from sessionStorage:', e);
            return defaultValue;
        }
    }
};

// ============================================================================
// MATH UTILITIES
// ============================================================================

const MathUtils = {
    /**
     * Clamp number between min and max
     * @param {number} num - Number to clamp
     * @param {number} min - Minimum value
     * @param {number} max - Maximum value
     * @returns {number} Clamped value
     */
    clamp(num, min, max) {
        return Math.min(Math.max(num, min), max);
    },

    /**
     * Map number from one range to another
     * @param {number} value - Value to map
     * @param {number} inMin - Input range minimum
     * @param {number} inMax - Input range maximum
     * @param {number} outMin - Output range minimum
     * @param {number} outMax - Output range maximum
     * @returns {number} Mapped value
     */
    map(value, inMin, inMax, outMin, outMax) {
        return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
    },

    /**
     * Linear interpolation
     * @param {number} start - Start value
     * @param {number} end - End value
     * @param {number} t - Interpolation factor (0-1)
     * @returns {number} Interpolated value
     */
    lerp(start, end, t) {
        return start + (end - start) * t;
    },

    /**
     * Round to decimal places
     * @param {number} num - Number to round
     * @param {number} decimals - Decimal places
     * @returns {number} Rounded number
     */
    roundTo(num, decimals) {
        const factor = Math.pow(10, decimals);
        return Math.round(num * factor) / factor;
    },

    /**
     * Get percentage of value
     * @param {number} value - Current value
     * @param {number} total - Total value
     * @returns {number} Percentage (0-100)
     */
    percentage(value, total) {
        if (total === 0) return 0;
        return (value / total) * 100;
    },

    /**
     * Convert degrees to radians
     * @param {number} degrees - Degrees
     * @returns {number} Radians
     */
    degToRad(degrees) {
        return degrees * (Math.PI / 180);
    },

    /**
     * Convert radians to degrees
     * @param {number} radians - Radians
     * @returns {number} Degrees
     */
    radToDeg(radians) {
        return radians * (180 / Math.PI);
    }
};

// ============================================================================
// EXPORT ALL UTILITIES
// ============================================================================

// Make all utilities available globally
if (typeof window !== 'undefined') {
    window.DateUtils = DateUtils;
    window.StringUtils = StringUtils;
    window.ValidationUtils = ValidationUtils;
    window.ArrayUtils = ArrayUtils;
    window.ObjectUtils = ObjectUtils;
    window.StorageUtils = StorageUtils;
    window.MathUtils = MathUtils;
}

</script>
